`timescale 1ns / 1ps

module rom (
    input  logic [31:0] addr,
    output logic [31:0] data
);
    logic [31:0] rom[0:127];

    initial begin
        //rom[x]=32'b fucn7 _ rs2 _ rs1 _f3 _ rd  _opcode;   // R-Type rd  rs1 rs2
        // rom[0]  = 32'b0000000_00001_00010_000_00100_0110011;  // add  x4,  x2, x1
        // rom[1]  = 32'b0100000_00001_00010_000_00100_0110011;  // sub  x4,  x2, x1
        // rom[2]  = 32'b0000000_00011_00010_001_00100_0110011;  // sll  x4,  x2, x3
        // rom[3]  = 32'b0000000_00011_00010_101_00100_0110011;  // srl  x4,  x2, x3
        // rom[4]  = 32'b0100000_00001_00010_101_00100_0110011;  // sra  x4,  x2, x1
        // rom[5]  = 32'b0000000_00001_00010_010_00100_0110011;  // slt  x4,  x2, x1
        // rom[6]  = 32'b0000000_00011_00010_010_00100_0110011;  // slt  x4, x2, x3
        // rom[7]  = 32'b0000000_00001_00010_011_00100_0110011;  // sltu x4, x2, x1
        // rom[8]  = 32'b0000000_00001_00010_100_00100_0110011;  // xor  x4, x2, x1
        // rom[9]  = 32'b0000000_00001_00010_110_00100_0110011;  // or   x4, x2, x1
        // rom[10] = 32'b0000000_00001_00010_111_00100_0110011;  // and  x4, x2, x1
        // //rom[x]=32'b imm7  _ rs2 _ rs1 _f3 _ imm5_ opcode; // S-Type rs2 imm(rs1)/4 =2번째
        // rom[11] = 32'b0000000_00101_00000_000_01000_0100011; //    sb x5, 8 (x0); 2
        // rom[12] = 32'b0000000_00101_00000_001_01100_0100011; //    sh x5, 12(x0); 3
        // rom[13] = 32'b0000000_00101_00000_010_10000_0100011; //    sw x5, 16(x0); 4
        // //rom[x]=32'b imm12      _ rs1 _f3 _ rd  _ opcode; // I-Type rd  rs1 imm
        // rom[14] = 32'b000000000001_00001_000_00110_0010011; // ADDI  x6, x1, 1;
        // rom[15] = 32'b000000001101_00001_010_00110_0010011; // SLTI  x6, x1, 13;
        // rom[16] = 32'b000000000001_00001_011_00110_0010011; // SLTIU x6, x1, 13;
        // rom[17] = 32'b000000000001_00001_100_00110_0010011; // XORI  x6, x1, 1;
        // rom[18] = 32'b000000000001_00001_110_00110_0010011; // ORI   x6, x1, 1;   
        // rom[19] = 32'b000000000001_00001_111_00110_0010011; // ANDI  x6, x1, 1;
        // rom[20] = 32'b000000000001_00001_001_00110_0010011; // SLLI  x6, x1, 1;
        // rom[21] = 32'b000000000001_00001_101_00110_0010011; // SRLI  x6, x1, 1;
        // rom[22] = 32'b000000000001_00001_101_00110_0010011; // SRAI  x6, x1, 1;
        // //rom[x]=32'b imm12          _ rs1 _f3 _ rd  _ opcode; //L-Type  rd    imm(rs1)/4 =2번째
        // rom[23] = 32'b000000001100_00000_000_00111_0000011; // LB        x7,  8(x0);
        // rom[24] = 32'b000000001100_00000_001_00111_0000011; // LH        x7,  8(x0);
        // rom[25] = 32'b000000001100_00000_010_00111_0000011; // LW        x7,  8(x0);
        // rom[26] = 32'b000000001100_00000_100_00111_0000011; // LBU       x7,  8(x0);
        // rom[27] = 32'b000000001100_00000_101_00111_0000011; // LHU       x7,  8(x0);
        // //rom[x]=32'b imm7_ rs2 _ rs1 _f3 _ imm5_ opcode; // B-Type rs1 rs2 imm  
        // rom[28] = 32'b0000000_00010_00010_000_00100_1100011; // BEQ   x1(11), x1(11), 4
        // rom[29] = 32'b0000000_00010_00001_001_01000_1100011; // BNE   x1(11), x2(12), 8
        // rom[30] = 32'b0000000_00010_00001_100_00100_1100011; // BLT   x1(11), x2(12), 4
        // rom[31] = 32'b0000000_00010_00011_101_01000_1100011; // BGE   x3(13), x2(12), 8
        // rom[32] = 32'b0000000_00010_00001_110_00100_1100011; // BLTU  x1(13), x2(12), 4
        // rom[33] = 32'b0000000_00010_00011_111_01100_1100011; // BGEU  x3(13), x2(12), 12

        // //rom[x]= 32'b              imm20  _ rd  _ opcode;// LU-Type  rd imm
        // rom[28] = 32'b00000000000000000001_01001_0110111; // LUI      x9, 12 

        // //rom[x]=32'b              imm20  _ rd _ opcode; //  AU-Type    rd imm  
        // rom[28] = 32'b00000000000000000001_01010_0010111; // AUIPC     x10, 12 

        // //rom[x]=32'b               imm20 _  rd _ opcode; // J-Type    rd imm  
        // rom[30] = 32'b00000000000000000001_01011_1101111; // JAL      x11, 12 

        //rom[x]=32'b        imm12_ rs1 _f3 _ rd _ opcode; // JL-Type   rd  rs1  imm  
        //rom[28] = 32'b000000000001_00010_000_01000_1100111; // JALR     x8, x1,  12 
    $readmemh("code.mem", rom); //hex로 ""파일을 읽어들이겠다, 그리고 rom에 값을 쓰겠다는 의미
    end
    assign data = rom[addr[31:2]];
endmodule
